<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Object - JavaScript学习网站</title>
    <link rel="stylesheet" href="../styles/main.css">
    <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@300;400;500;700&display=swap" rel="stylesheet">
    <style>
        .note-container {
            max-width: 900px;
            margin: 2rem auto;
            padding: 2rem;
            background: white;
            border-radius: 12px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.1);
        }
        .note-header {
            border-bottom: 2px solid #667eea;
            padding-bottom: 1rem;
            margin-bottom: 2rem;
        }
        .note-title {
            font-size: 2.5rem;
            font-weight: 700;
            color: #333;
            margin: 0;
        }
        .note-meta {
            color: #666;
            font-size: 0.9rem;
            margin-top: 0.5rem;
        }
        .note-content {
            line-height: 1.8;
            color: #444;
        }
        .back-btn {
            position: fixed;
            top: 20px;
            left: 20px;
            background: #667eea;
            color: white;
            border: none;
            padding: 12px;
            border-radius: 50%;
            cursor: pointer;
            box-shadow: 0 2px 8px rgba(0,0,0,0.2);
            z-index: 1000;
            transition: all 0.3s ease;
        }
        .back-btn:hover {
            background: #5a6fd8;
            transform: scale(1.1);
        }
        .print-btn {
            position: fixed;
            top: 20px;
            right: 20px;
            background: #4caf50;
            color: white;
            border: none;
            padding: 12px;
            border-radius: 50%;
            cursor: pointer;
            box-shadow: 0 2px 8px rgba(0,0,0,0.2);
            z-index: 1000;
            transition: all 0.3s ease;
        }
        .print-btn:hover {
            background: #45a049;
            transform: scale(1.1);
        }
    </style>
</head>
<body>
    <button class="back-btn" onclick="history.back()" title="返回">
        <i class="material-icons">arrow_back</i>
    </button>
    
    <button class="print-btn" onclick="window.print()" title="打印">
        <i class="material-icons">print</i>
    </button>
    
    <div class="note-container">
        <div class="note-header">
            <h1 class="note-title">Object</h1>
            <div class="note-meta">
                <span><i class="material-icons" style="font-size: 16px; vertical-align: middle;">description</i> Object.md</span>
                <span style="margin-left: 1rem;"><i class="material-icons" style="font-size: 16px; vertical-align: middle;">schedule</i> 2025/6/26 23:37:55</span>
            </div>
        </div>
        
        <div class="note-content">
            </p><h1>Object  </h1><br><h2>Property</h2><br><h3>in操作符  </h3><br><code>prop_key in object</code><br>会去原型链上查找<br><h3>hasOwnProperty</h3><br><code>obj.hasOwnProperty(prop_key)</code>   <br>不会去原型链上查找  <br><code>Object.getOwnPropertyNames(obj) Object.getOwnPropertySymbols(obj)</code>   <br>返回一个数组包含obj拥有的所有string/symbol类型的key   <br><ul style="margin: 1rem 0; padding-left: 2rem;"><br><li>让这两个方法绑定在具体对象上的方法  </li><br></ul><br>    <br>                <div class="code-block" style="margin: 1.5rem 0; border-radius: 8px; overflow: hidden; box-shadow: 0 2px 4px rgba(0,0,0,0.1);"><br>                    <div class="code-header" style="background: #f5f5f5; padding: 0.5rem 1rem; border-bottom: 1px solid #ddd; font-size: 0.9rem; color: #666; font-weight: 500;">JavaScript</div><br>                    <pre style="background: #f8f9fa; padding: 1.5rem; margin: 0; overflow-x: auto; border-left: 4px solid #667eea;"><code class="language-javascript">// 1. 扩展 Object.prototype<br>    Object.prototype.getPropertyNames = function(){<br>        return Object.getOwnPropertyNames(this);<br>    };<br>    const obj = {a:1, b:2};<br>    obj.getPropertyNames();<br>    <br>    // 2.自定义类<br>    class MyObject{<br>        constructor(data){<br>            Object.assign(this,data);<br>        }<br>        getPropertyNames(){<br>            return Object.getOwnPropertyNames(this);<br>        }<br>    }<br>    const obj = new MyObject({a:1,b:2});<br>    obj.getPropertyNames();</code></pre><br>                </div><br>            <br><h3>定义data property的无糖形式  </h3><br><code>Object.defineProperty(obj, prop_key, prop_des)</code>   </p><p>                <div class="code-block" style="margin: 1.5rem 0; border-radius: 8px; overflow: hidden; box-shadow: 0 2px 4px rgba(0,0,0,0.1);"><br>                    <div class="code-header" style="background: #f5f5f5; padding: 0.5rem 1rem; border-bottom: 1px solid #ddd; font-size: 0.9rem; color: #666; font-weight: 500;">JavaScript</div><br>                    <pre style="background: #f8f9fa; padding: 1.5rem; margin: 0; overflow-x: auto; border-left: 4px solid #667eea;"><code class="language-javascript">let obj = {};<br>Object.defineProperty(obj, "age", {<br>    value       : 28,<br>    writable    : true,<br>    enumerable  : false,<br>    configurable: false,   <br>})</code></pre><br>                </div><br>            <br>严格模式下对不可写的property进行赋值会触发运行时错误，一般模式下不会     <br><h3>accessor property 保护</h3><p><p>                <div class="code-block" style="margin: 1.5rem 0; border-radius: 8px; overflow: hidden; box-shadow: 0 2px 4px rgba(0,0,0,0.1);"><br>                    <div class="code-header" style="background: #f5f5f5; padding: 0.5rem 1rem; border-bottom: 1px solid #ddd; font-size: 0.9rem; color: #666; font-weight: 500;">JavaScript</div><br>                    <pre style="background: #f8f9fa; padding: 1.5rem; margin: 0; overflow-x: auto; border-left: 4px solid #667eea;"><code class="language-javascript">const Person = function(name){<br>    let my_age = 18;<br>    return {<br>        name,<br>        get age(){return my_age;},<br>        set age(v){<br>            if(v &lt; 0) throw new Errow("nagetive age");<br>            my_age = v;<br>        }<br>    }<br>}<br>let zhs = new Person("xiaoming"); <br>zhs.age = -19;<br>console.log(zhs.age)<br>//若没有get，读取该property时会返回undefined<br>//若没有set, 严格模式下对该属性赋值会报错，一般模式下会忽略该赋值语句</code></pre><br>                </div><br>            <br>一个property具有一个key和一个property descriptor<br>descriptor有6个attributes:    <br>1.enumerable 2.configurable  <br>3.value 4.writable 5.get 6.set   <br>data型拥有1,2,3,4 accessor型拥有1,2,5,6   <br><code>Object.getOwnPropertyDescriptor(obj, prop_key)  Object.defineProperty(obj, prop_key, prop_des)</code>  <br>prop_des缺省情况下创建的是data property(2,3,4都是false)   <br>value/writable <strong>互斥</strong> set/get 同时出现会导致运行时错误  <br><h3>configurable 含义:  </h3><br>true: 可以修改descriptor信息 可用delete删除   <br>false: 只能进行两种类型修改:   <br><ol style="margin: 1rem 0; padding-left: 2rem;"><br><li>writable为false: 把writable改为true</li><br><li>writable为true: 修改value值  </li><br></ol><br><h3>enumerable含义</h3><br>for-in遍历条件：property的enumerable为true && key类型为string(<em>包含原型链</em>)     <br><h3>for-of</h3><br>很多built-in constructor 创建的object都是iterable的 eg:Array, string, number...  <br><h2>Iterable object</h2><br>具有一个key为Symbol.iterator(ES的一个well-known symbol)的property，该property的value是一个function，调用会返回一个iterator      <br>一个iterator是一个object，具有一个名称为next的方法，对next的调用返回一个object: <br><ol style="margin: 1rem 0; padding-left: 2rem;"><br><li>done: true: 已遍历所有值 false: 还有未遍历到的  </li><br><li>value: 在done为false时有意义，为当前遍历到的值 </li><br></ol><br>如果不存在done 被解释为false   <br>done为true的时候value可以不存在，也可以指向一个值，但是不能解释为待遍历的值  </p><p>                <div class="code-block" style="margin: 1.5rem 0; border-radius: 8px; overflow: hidden; box-shadow: 0 2px 4px rgba(0,0,0,0.1);"><br>                    <div class="code-header" style="background: #f5f5f5; padding: 0.5rem 1rem; border-bottom: 1px solid #ddd; font-size: 0.9rem; color: #666; font-weight: 500;">JavaScript</div><br>                    <pre style="background: #f8f9fa; padding: 1.5rem; margin: 0; overflow-x: auto; border-left: 4px solid #667eea;"><code class="language-javascript">let vs = [1,2,3];</p><p>for(let v of vs){<br>    console.log(v);<br>}</p><p>//等价形式（实质）<br>const itr = vs[Symbol.iterator]();<br>let next = itr.next();<br>while(!next.done){<br>    let v = next.value;<br>    console.log(v);<br>    next = itr.next();<br>}</code></pre><br>                </div><br>            <br>逆序遍历:  </p><p>                <div class="code-block" style="margin: 1.5rem 0; border-radius: 8px; overflow: hidden; box-shadow: 0 2px 4px rgba(0,0,0,0.1);"><br>                    <div class="code-header" style="background: #f5f5f5; padding: 0.5rem 1rem; border-bottom: 1px solid #ddd; font-size: 0.9rem; color: #666; font-weight: 500;">JavaScript</div><br>                    <pre style="background: #f8f9fa; padding: 1.5rem; margin: 0; overflow-x: auto; border-left: 4px solid #667eea;"><code class="language-javascript">vs.reverse = function(){<br>    return{<br>        [Symbol.iterator] : () =&gt; {<br>            //这里的this因为是箭头函数的this，所以继承了外层作用域<br>            let i = this.length - 1;<br>            return {<br>                next: () =&gt; {<br>                    let done = (i &lt; 0);<br>                    let value = !done ? this[i--] : undefined;</p><p>                    return{done, value};<br>                }<br>            };<br>        }<br>    }<br>}<br>for(let v of vs.reverse()) console.log(v);<br>//如果想访问原型链上的reverse方法:<br>let proto = Object.getPrototypeOf(vs);<br>proto.reverse.call(vs);<br>for(let v of vs) console.log(v);</code></pre><br>                </div><br>            <br>带过滤的数组便利:</p><p>                <div class="code-block" style="margin: 1.5rem 0; border-radius: 8px; overflow: hidden; box-shadow: 0 2px 4px rgba(0,0,0,0.1);"><br>                    <div class="code-header" style="background: #f5f5f5; padding: 0.5rem 1rem; border-bottom: 1px solid #ddd; font-size: 0.9rem; color: #666; font-weight: 500;">JavaScript</div><br>                    <pre style="background: #f8f9fa; padding: 1.5rem; margin: 0; overflow-x: auto; border-left: 4px solid #667eea;"><code class="language-javascript">let vs = [1,2,3,4,5,6];</p><p>vs.filter = function(call_back){<br>    let itr = this[Symbol.iterator]();</p><p>    return{<br>        [Symbol.iterator] : () =&gt;({<br>            next : () =&gt; {<br>                let next, done, value, valid;<br>                while(!done &amp;&amp; !valid){<br>                    next = itr.next();<br>                    done = next.done;<br>                    value = next.value;<br>                    valid = call_back(value);<br>                }<br>                return {done,value};<br>            }<br>        }),<br>        filter : this.filter<br>    }<br>}<br>for(let v of vs.filter(v =&gt; v%2 == 0)) console.log(v);<br>//串联:<br>for(let v of vs.filter(v =&gt; v%2 == 0)<br>               .filter(v =&gt; v &gt; 2)<br>               .filter(v =&gt; v &lt; 6)) console.log(v);</code></pre><br>                </div><br>            <br>for-of vs range-based for:</p><p>                <div class="code-block" style="margin: 1.5rem 0; border-radius: 8px; overflow: hidden; box-shadow: 0 2px 4px rgba(0,0,0,0.1);"><br>                    <div class="code-header" style="background: #f5f5f5; padding: 0.5rem 1rem; border-bottom: 1px solid #ddd; font-size: 0.9rem; color: #666; font-weight: 500;">JavaScript</div><br>                    <pre style="background: #f8f9fa; padding: 1.5rem; margin: 0; overflow-x: auto; border-left: 4px solid #667eea;"><code class="language-javascript">let vs = [1,2,3];<br>for(let v of vs) v++;<br>for(let v of vs) console.log(v);<br>//输出仍然是1，2，3<br>//通过for-of修改数组？<br>for(const [index,value] of vs.entries()){<br>    vs[index] = value + 1;<br>}</code></pre><br>                </div><br>            <br>symbol类型: 提供一种<em>存储无关</em>的方式来表达一个符号  <br><ul style="margin: 1rem 0; padding-left: 2rem;"><br><li>初始动机: 为object加入 private property  </li><br><li>实际使用: 定制/扩展系统的一种方式（<em>well-known symbols</em>）   </li><br></ul><p><p><em>C++ 中range-based for 也是语法糖？</em><br>``<code>c++<br>auto vs = std::vector<int>{1,2,3};<br>//for(auto & v : vs) v++;<br>for(auto pos = vs.begin(), end = vs.end(); pos != end; ++pos){<br>    auto & v = *pos;<br>    v++;<br>}</p><p>                <div class="code-block" style="margin: 1.5rem 0; border-radius: 8px; overflow: hidden; box-shadow: 0 2px 4px rgba(0,0,0,0.1);"><br>                    <br>                    <pre style="background: #f8f9fa; padding: 1.5rem; margin: 0; overflow-x: auto; border-left: 4px solid #667eea;"><code class="language-">range-v3库</code></pre><br>                </div><br>            c++<br>#include<range/v3/all.hpp><br>#include<vector><br>#include<iostream><br>using namespace ranges::views;<br>int main(){<br>    auto vs = std::vector<ixnt>{1,2,3,4,5,6,7,8,9};<br>    for(auto & v : vs | filter([](const int & v){ return v %2 == 0; })<br>                      | reverse<br>                      | filter([](const int & v){ return v > 2; })<br>                      | filter([](const int & v){ return v < 8; }))<br>    std::cout << v << std::endl;<br>}<br>//编译命令:g++ -std=c++20 -I/opt/homebrew/opt/range-v3/include try.cpp -o try<br>//需指定c++17以上版本以及range-v3库的路径</p><p>                <div class="code-block" style="margin: 1.5rem 0; border-radius: 8px; overflow: hidden; box-shadow: 0 2px 4px rgba(0,0,0,0.1);"><br>                    <br>                    <pre style="background: #f8f9fa; padding: 1.5rem; margin: 0; overflow-x: auto; border-left: 4px solid #667eea;"><code class="language-">### spread操作符<br><ol style="margin: 1rem 0; padding-left: 2rem;"><br><li>将数组分解为一组元素后传入函数</li><br><ul style="margin: 0.5rem 0; padding-left: 1.5rem;"><br><li>eg.   </li><br></ul><br></ol><br>   </code>let values = [1,2,3]<code>    <br>   </code>Math.max(...values);<code><br><ol style="margin: 1rem 0; padding-left: 2rem;"><br><li>数组初始化</li><br><ul style="margin: 0.5rem 0; padding-left: 1.5rem;"><br><li>eg   </li><br></ul><br></ol><br>   </code>const a1 = [3,4,5];<code>   <br>   </code>const a2 = [1,2,...a1,7,8];<code>   <br>   a2: [1,2,3,4,5,7,8]   <br><h2>Prototype  </h2><br><ul style="margin: 1rem 0; padding-left: 2rem;"><br><li>每一个object关联且仅关联一个Prototype，是一个object/null  </li><br><li>Prototype是object的一种internal state，存在名为[[Prototype]]的internal slot中  </li><br><li>原型链中有环会触发</code>TypeError: Cyclic __proto__ value<code>  </li><br><li>通过<strong>字面量</strong>创建的object/function，在缺省情况下原型链的长度为2/3 原型链分别为:</li><br><ul style="margin: 0.5rem 0; padding-left: 1.5rem;"><br><li>object -&gt; object -&gt; null</li><br><li>function -&gt; function -&gt; object -&gt; null</li><br><li>上面两个原型链中的object是同一个(<strong><em>Object.prototype</em></strong>)</li><br><li><img src="../img/prototype.png" alt="" style="max-width: 100%; height: auto; border-radius: 8px; margin: 1rem 0;"></li><br></ul><br></ul><br><h3>\_\_proto__ 和 prototype</h3><br><img src="../img/protonet.png" alt="" style="max-width: 100%; height: auto; border-radius: 8px; margin: 1rem 0;"><br>①__proto__和constructor属性是对象所独有的；② prototype属性是函数所独有的   <br>通过__proto__属性来连接对象直到null的一条链即为我们所谓的原型链，作用：沿原型链寻找属性      <br>prototype的含义是函数的原型对象，也就是这个函数所创建的实例的原型对象 作用：让该函数所实例化的对象们都可以找到公用的属性和方法   <br>constructor属性含义是指向该对象的构造函数； <strong>Function</strong>这个对象比较特殊，它的<em>构造函数就是它自己</em>.   <br>所有函数和对象最终都是由Function构造函数得来，所以constructor属性的终点就是Function这个函数    <br>每一个可以作为constructor的function都有一个key为"prototype"的property， prototype的值在缺省情况下是一个object，该object有一个key为"constructor"的property  <br>用constructor的方式调用一个func时，返回的obj一般情况下（obj是调用中缺省的this，且没有改变obj.[[Prototype]]的值），满足: <br>&lt;span style="color:lightblue"&gt;<strong>obj</strong>&lt;/span&gt;&lt;span style="color:yellow"&gt;.<strong>[[Prototype]]</strong> === &lt;/span&gt;&lt;span style="color:lightblue"&gt;<strong>func</strong>&lt;/span&gt;&lt;span style="color:yellow"&gt;.<strong>prototype</strong>&lt;/span&gt;  </p></p><h3>字面量 和 constructor  </h3><br><img src="../img/LitVSCons.png" alt="" style="max-width: 100%; height: auto; border-radius: 8px; margin: 1rem 0;"></p></p><h3>基于原型的继承  </h3><br>#### 方法一（原型链继承）<br>&lt;img src="../img/output.png" width="100"  align="right"&gt;</code></pre><br>                </div><br>            javascript<br>"use strict"<br>const mammal = function(weight){<br>  this.weight = weight;<br>}<br>mammal.prototype.get_weight = function(){<br>  return this.weight;<br>}</p><p>const Person = function(name, weight){<br>  this.name = name;<br>  this.weight = weight;<br>}<br>//使 Person 继承 mammal 的所有属性和方法<br>//链接 Person.prototype -> mammal.prototype<br>Person.prototype = new mammal();<br>Person.prototype.get_name = function(){<br>  return this.name;<br>}</p><p>/*Object.defineProperty(Person.prototype, "constructor", {<br>  value: Person,<br>  writable: true,<br>  configurable: true,<br>  enumerable : false<br>})*/</p><p>const zhs = new Person("zhangsan", "70kg");</p><p>for (const key in Person.prototype) {<br>  if (Person.prototype.hasOwnProperty(key)) {  // 只枚举自身属性<br>    console.log(key);             <br>  }<br>}<br>console.log("-----------")<br>for (const key in zhs) {<br>  if (zhs.hasOwnProperty(key)) {  // 只枚举自身属性<br>    console.log(key);             <br>  }<br>}<br>console.log("-----------")</p><p>console.log(zhs.constructor == Person)<br>console.log(zhs.constructor == mammal)</p><p>                <div class="code-block" style="margin: 1.5rem 0; border-radius: 8px; overflow: hidden; box-shadow: 0 2px 4px rgba(0,0,0,0.1);"><br>                    <br>                    <pre style="background: #f8f9fa; padding: 1.5rem; margin: 0; overflow-x: auto; border-left: 4px solid #667eea;"><code class="language-">（加上注释内容会把constructor改为Person，注意constructor的enumerable为false）  <br>#### 方法二（伪经典/ES5风格继承）<br>&lt;img src="../img/output2.png" width="100"  align="right"&gt;</code></pre><br>                </div><br>            javascript<br>"use strict"<br>const mammal = function(weight){<br>  this.weight = weight;<br>}<br>mammal.prototype.get_weight = function(){<br>  return this.weight;<br>}</p><p>const Person = function (name,weight){<br>    const person = new mammal(weight)<br>    person.name = name;<br>    Object.setPrototypeOf(person, Person.prototype);<br>    return person;<br>}<br>Object.setPrototypeOf(Person.prototype, mammal.prototype);<br>Person.prototype.get_name = function(){<br>    return this.name;<br>}</p><p>const zhs = new Person("zhangsan", "70kg");</p><p>for (const key in Person.prototype) {<br>  if (Person.prototype.hasOwnProperty(key)) {  // 只枚举自身属性<br>    console.log(key);             <br>  }<br>}<br>console.log("-----------")<br>for (const key in zhs) {<br>  if (zhs.hasOwnProperty(key)) {  // 只枚举自身属性<br>    console.log(key);             <br>  }<br>}<br>console.log("-----------")</p><p>console.log(zhs.constructor == Person)<br>console.log(zhs.constructor == mammal)</p><p>                <div class="code-block" style="margin: 1.5rem 0; border-radius: 8px; overflow: hidden; box-shadow: 0 2px 4px rgba(0,0,0,0.1);"><br>                    <br>                    <pre style="background: #f8f9fa; padding: 1.5rem; margin: 0; overflow-x: auto; border-left: 4px solid #667eea;"><code class="language-">#### instanceof 操作符  <br>left instanceof rightCF:  <br><ol style="margin: 1rem 0; padding-left: 2rem;"><br><li>如果left不是object，返回false</li><br><li>如果 rightCF.<strong>prototype</strong> 在left的原型链上返回true，否则返回false  </li><br></ol><p></p><h2>class，extends</code></pre></h2><br>                </div><br>            javascript<br>"use strict"<br>class Person{<br>  constructor(name, age){<br>    this.name = name;<br>    this.age = age;<br>  }<br>  get_name(){ return this.name; }<br>  get_age(){ return this.age; }<br>}</p><p>//无糖形式:<br>let Person = (function(){<br>  "use strict";<br>  const Person = function(name){<br>    if(new.target === undefined){ //强制使用new调用<br>      throw new Error("no new operator");<br>    }<br>    this.name = name;<br>  }</p><p>  Object.defineProperties(Person.prototype, {<br>    get_name : {<br>      value: function(){ return this.name; },<br>      enumerable: false,<br>      writable: true,<br>      configurable: true<br>    }<br>  })<br>  return Person;<br>}());</p><p>                <div class="code-block" style="margin: 1.5rem 0; border-radius: 8px; overflow: hidden; box-shadow: 0 2px 4px rgba(0,0,0,0.1);"><br>                    <br>                    <pre style="background: #f8f9fa; padding: 1.5rem; margin: 0; overflow-x: auto; border-left: 4px solid #667eea;"><code class="language-">(function(){...}(): 立即执行的匿名函数, 可以形成块级作用域)  <br><ul style="margin: 1rem 0; padding-left: 2rem;"><br><li>class中静态方法:</code></pre></li><br></ul><br>                </div><br>            javascript<br>  class Person{<br>      constructor(name){ this.name = name; }<br>      get_name(){ return this.name; }<br>      static create(name){<br>          return new this(name); //this指向Person类而非实例<br>      }<br>  }<br>  let zhs = Person.create("zhangsan");<br>  <br>  //另一种方法:<br>  let Person = function(name){ this.name = name; }<br>  Person.prototype.get_name = function(){<br>      return this.name;<br>  }  <br>  Person.create = function(name){ //静态方法定义在类而非原型上<br>      return new this(name);<br>  }<br>  <br>                <div class="code-block" style="margin: 1.5rem 0; border-radius: 8px; overflow: hidden; box-shadow: 0 2px 4px rgba(0,0,0,0.1);"><br>                    <br>                    <pre style="background: #f8f9fa; padding: 1.5rem; margin: 0; overflow-x: auto; border-left: 4px solid #667eea;"><code class="language-">- computed member names</code></pre><br>                </div><br>            javascript<br>    let my_name = "get_name"; //可以在运用时才确定方法名<br>    class Person {<br>        constructor(name){ this.name = name; }<br>        [my_name](){ return this.name; }<br>    }<br>    let zhs = new Person("zhangsan");<br>    console.log(zhs.get_name());<br>    <br>                <div class="code-block" style="margin: 1.5rem 0; border-radius: 8px; overflow: hidden; box-shadow: 0 2px 4px rgba(0,0,0,0.1);"><br>                    <br>                    <pre style="background: #f8f9fa; padding: 1.5rem; margin: 0; overflow-x: auto; border-left: 4px solid #667eea;"><code class="language-">- class expression</code></pre><br>                </div><br>            javascript<br>    let zhs = new class{<br>        constructor(name){ this.name = name; }<br>        get_name(){ return this.name; }<br>    }("zhangsan");<br>    <br>                <div class="code-block" style="margin: 1.5rem 0; border-radius: 8px; overflow: hidden; box-shadow: 0 2px 4px rgba(0,0,0,0.1);"><br>                    <br>                    <pre style="background: #f8f9fa; padding: 1.5rem; margin: 0; overflow-x: auto; border-left: 4px solid #667eea;"><code class="language-">- extends</code></pre><br>                </div><br>            javascript<br>    class Mammal {<br>        cunstuctor(weight){ this.weight = weight; }<br>        get_weight(){ return this.weight; }<br>    }   <br>    class Person extends Mammal{ //extends后面可以是任意可以作为constructor的function<br>        constructor(name,weight){  //如果没写系统会提供一个缺省值<br>            super(weight);  //访问this之前必须调用父类的constructor<br>            this.name = name;<br>        }<br>        get_name(){ return this.name; }<br>        //子类中覆盖父类的方法:<br>        get_weight(){<br>            return super.get_weight() + "so heavy!"<br>        }<br>    }<br>    //原型链: 实例 -> Person.prototype -> Mammal.prototype<br>    <br>                <div class="code-block" style="margin: 1.5rem 0; border-radius: 8px; overflow: hidden; box-shadow: 0 2px 4px rgba(0,0,0,0.1);"><br>                    <br>                    <pre style="background: #f8f9fa; padding: 1.5rem; margin: 0; overflow-x: auto; border-left: 4px solid #667eea;"><code class="language-">## Object 上一些方法  <br></code>Object.create(proto, properties)<code>  <br>实质行为:</code></pre><br>                </div><br>            javascript<br>Object.create = (proto, properties) => {<br>	let obj = {};<br>	Object.setPrototypeOf(obj, proto);<br>	if(properties != undefined){<br>		Object.defineProperties(obj, properties);<br>	}<br>	return obj;<br>}</p><p>                <div class="code-block" style="margin: 1.5rem 0; border-radius: 8px; overflow: hidden; box-shadow: 0 2px 4px rgba(0,0,0,0.1);"><br>                    <br>                    <pre style="background: #f8f9fa; padding: 1.5rem; margin: 0; overflow-x: auto; border-left: 4px solid #667eea;"><code class="language-"></code>Object.assign(target, ...sources)<code>  <br>将源对象的可枚举自有属性复制到目标对象  <br>如果多个源对象有相同的属性键，后面的会覆盖前面的   <br>只复制属性值（浅拷贝）  <br>不会复制不可枚举的和原型链上的属性</code></pre><br>                </div><br>            javascript<br>Object.assign = (target,...sources) => {<br>	if(target === undefined || target === null)<br>		throw TypeError("...");<br>	let to = Object(target); //把target转化为一个object  <br>	<br>	for(let s of sources){<br>		let keys = [];<br>		let from;<br>		if(s !== undefined && s !== null){ //要求属性可枚举<br>			from = Object(s);<br>			let str_keys = Object.getOwnPropertyNames(from);<br>			let syb_keys = Object.getOwnPropertySymbols(from);<br>			keys = [...str_keys, ...syb_keys];<br>		}</p><p>		for(let key of keys){<br>			let desc = Object.getOwnPropertyDescriptor(from, key);<br>			let v = from[key];<br>			to[key] = v; //后面会覆盖前面<br>		}<br>	}<br>	return to;<br>}</p><p>                <div class="code-block" style="margin: 1.5rem 0; border-radius: 8px; overflow: hidden; box-shadow: 0 2px 4px rgba(0,0,0,0.1);"><br>                    <br>                    <pre style="background: #f8f9fa; padding: 1.5rem; margin: 0; overflow-x: auto; border-left: 4px solid #667eea;"><code class="language-"></code>Object.preventExtensions(obj)<code>  <br>把obj的[[Extensible]]设为false  <br>无法添加新的property/设置新的[[prototype]]  <br>操作不可逆，可通过Object.isExtensible(obj)获得[[Extensible]]的值   <br></code>Object.seal(obj)<code>  <br>把obj的[[Extensible]]设为false +   <br>所有properties的configurable设为false  <br></code>Object.freeze(obj)<code>  <br>把obj的[[Extensible]]设为false +  <br>所有properties的configurable设为false +   <br>所有data properties的writable设为false   </p></p><h2>Collections  </h2><br>三种built-in objects: Array, Map, Set  <br><h3>Array</h3><br>队尾: </code>.push() / .pop()<code>  <br>队首: </code>.unshift() / .shift()<code>  <br></code>.splice(start, deleteCount, ...items)<code>   <br></code>.slice(start, end)<code> : [start,end)  <br></code>.forEach(callback(currentvalue,index,arr) ,thisValue)<code></code></pre><br>                </div><br>            javascript<br>function forEach(call_back_fn, thisArg = undefined){<br>	const o = this, len = o.length, t = thisArg;<br>	let k = 0;<br>	while(k < len){<br>		if(k in o){ //只对实际存在的元素回调<br>			const v = o[k];<br>			call_back_fn.call(t, v, k, o);<br>		}<br>		k++;<br>	}	<br>}</p><p>                <div class="code-block" style="margin: 1.5rem 0; border-radius: 8px; overflow: hidden; box-shadow: 0 2px 4px rgba(0,0,0,0.1);"><br>                    <br>                    <pre style="background: #f8f9fa; padding: 1.5rem; margin: 0; overflow-x: auto; border-left: 4px solid #667eea;"><code class="language-"></code>.map(callbackFn, thisArg)<code>  <br></code>.filter(callbackFn, thisArg)<code>  <br></code>.reduce(callbackFn, initialValue = array[0])<code>  <br><ul style="margin: 1rem 0; padding-left: 2rem;"><br><li>eg:</code></pre></li><br></ul><br>                </div><br>            javascript<br>  const vs = [1,2,3,4,5,6,7,8,9,10];<br>  const sum = vs.reduce((acc, v) => acc + v);<br>  <br>                <div class="code-block" style="margin: 1.5rem 0; border-radius: 8px; overflow: hidden; box-shadow: 0 2px 4px rgba(0,0,0,0.1);"><br>                    <br>                    <pre style="background: #f8f9fa; padding: 1.5rem; margin: 0; overflow-x: auto; border-left: 4px solid #667eea;"><code class="language-"></code>.sort(compareFn)<code><br><ul style="margin: 1rem 0; padding-left: 2rem;"><br><li>eg:</code></pre></li><br></ul><br>                </div><br>            javascript<br>  const vs = [1,2,3,4,5,6,7,8,9,10];<br>  vs.sort((v0, v1) => {<br>    if(v0 < v1) return -1; //<0<br>    else  return +1; //>0<br>    return 0;<br>  })<br>  <br>                <div class="code-block" style="margin: 1.5rem 0; border-radius: 8px; overflow: hidden; box-shadow: 0 2px 4px rgba(0,0,0,0.1);"><br>                    <br>                    <pre style="background: #f8f9fa; padding: 1.5rem; margin: 0; overflow-x: auto; border-left: 4px solid #667eea;"><code class="language-"></code>.every/some(callbackFn)<code>   <br>  </code>find(callbackFn)<code> 查找满足条件的第一个值  <br>  </code>Array.prototype.indexOf lastIndexOf findIndex<code>  </p></p><h3>Map  </h3><br>“键-值”对形成的有序列表, 任何类型的值都可以作为键  <br>方法: set, get, size, has, delete, clear  <br>for-of 遍历:<br>item of dict, key of dict.keys(), value of dict.values()   <br>dict.forEach((v,k,o) =&gt; { })  <br><h3>Set</h3><br>集合变为数组: [...set]  <br>并集: </code>new Set[...s1, ...s2]<code>  <br>交集: </code>new Set([...s1].filter(v =&gt; s2.has(v)))<code>   </p></p><h2>Destructing  </h2><br>对象析构：把object中property的值赋值给变量</code></pre><br>                </div><br>            javascript  <br>let node = {<br>  type: "Identifier", <br>  name: "foo"<br>}</p><p>let{type, name} = node;<br>//必须初始化，右侧值不能为null/undefined<br>//或: <br>({ type, name } = node);<br>//析构赋值表达式值为赋值符号右侧表达式的值<br>//缺省值:  <br>let{ type, name, value = true } = node;<br>//变量重命名:<br>let{ type : localType, name: localName} = node;</p><p>//嵌套object: <br>let node = {<br>    type: "Identifier",<br>    name: "foo",<br>    loc: {<br>        start: {<br>            line: 1,<br>            column: 2<br>        }<br>    },<br>    range: [0, 3]<br>};</p><p>let { loc: { start } } = node;</p><p>console.log(start.line); // 1  <br>console.log(start.column); // 2</p><p>                <div class="code-block" style="margin: 1.5rem 0; border-radius: 8px; overflow: hidden; box-shadow: 0 2px 4px rgba(0,0,0,0.1);"><br>                    <br>                    <pre style="background: #f8f9fa; padding: 1.5rem; margin: 0; overflow-x: auto; border-left: 4px solid #667eea;"><code class="language-">数组析构:</code></pre><br>                </div><br>            javascript<br>let colors = ["red", "blue", "green"];<br>let [first, second] = colors;<br>let[, , third] = colors;<br>let[first, ...rest] = colors; //rest.length = 2  </p><p>                <div class="code-block" style="margin: 1.5rem 0; border-radius: 8px; overflow: hidden; box-shadow: 0 2px 4px rgba(0,0,0,0.1);"><br>                    <br>                    <pre style="background: #f8f9fa; padding: 1.5rem; margin: 0; overflow-x: auto; border-left: 4px solid #667eea;"><code class="language-">参数析构:</code></pre><br>                </div><br>            javascript<br>function setCookie(name, value, options){<br>  options = options || {};<br>  let secure = options.secure, <br>      path = options.path,<br>      domain = options.domain,<br>      expires = options.expires;<br>};</p><p>setCookie("type", "js", {<br>  secure : true,<br>  expires : 60000<br>});<br></code>``<br>Optional chaining operator: ?. <br>左操作数是 null 或 undefined时返回undefined  </p>
        </div>
    </div>
    
    <script>
        // 添加代码高亮
        document.addEventListener('DOMContentLoaded', function() {
            // 为代码块添加复制功能
            const codeBlocks = document.querySelectorAll('pre code');
            codeBlocks.forEach(block => {
                const pre = block.parentElement;
                const copyBtn = document.createElement('button');
                copyBtn.innerHTML = '<i class="material-icons">content_copy</i>';
                copyBtn.className = 'copy-btn';
                copyBtn.style.cssText = 'position: absolute; top: 8px; right: 8px; background: #667eea; color: white; border: none; padding: 4px; border-radius: 4px; cursor: pointer; font-size: 12px;';
                
                copyBtn.onclick = function() {
                    navigator.clipboard.writeText(block.textContent).then(() => {
                        copyBtn.innerHTML = '<i class="material-icons">check</i>';
                        setTimeout(() => {
                            copyBtn.innerHTML = '<i class="material-icons">content_copy</i>';
                        }, 2000);
                    });
                };
                
                pre.style.position = 'relative';
                pre.appendChild(copyBtn);
            });
        });
    </script>
</body>
</html>